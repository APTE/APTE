# Needham Schroeder Symmetric Key
# http://www.lsv.ens-cachan.fr/Software/spore/nspkLowe.html
# We test a kind of strong secrecy of N_B (at the end of the protocol, B sends {ok}_Nb on the left
# and new n; {n}_Nb on the right.
# TRUE

############################################
# A,B,S :		        Principal
# Na,Nb :           	        Nonce
# KPa,KPb,KPs,KSa,KSb,KSs :	Key
# KPa,KSa :  		is a key pair
# KPb,KSb :  		is a key pair
# KPs,KSs :  		is a key pair
#
# 1.  	A -> S :   A,B
# 2.  	S -> A :   {KPb, B}KSs
# 3.  	A -> B :   {Na, A}KPb
# 4.  	B -> S :   B,A
# 5.  	S -> B :   {KPa, A}KSs
# 6.  	B -> A :   {Na, Nb, B}KPa
# 7.  	A -> B :   {Nb}KPb
############################################

free A.
free B.
free I.
free I2.

free c.
free c1.
free ca1.
free cb1.
free cs1.

free c2.
free ca2.
free cb2.
free cs2.

free c3.
free ca3.
free cb3.
free cs3.

free k_I.
free ok.
free bad.
free non_sec.

#######################################
#    Description of principal S :     #
#######################################

let processS k_A k_B k_I k_S cs =
  in(cs,x);
  let (xa,xb) = x in
  (
  (if xb = A then out(cs, senc((pk(k_A),A),k_S)))
  | 
  (if xb = B then out(cs, senc((pk(k_B),B),k_S)))
  |
  (if xb = I then out(cs, senc((pk(k_I),I),k_S)))
  ).

#######################################
#    Description of principal A :     #
#######################################

let processA k_S k_A ca =
  out(ca, (A,B));

  in(ca, x);
  let (xpkb, xb) = sdec(x, k_S) in
  new N_a;
  out(ca, aenc((N_a,A), xpkb));

  in(ca,y);
  let (xna,xnb,xb2) = adec(y,k_A) in
  if xna = N_a && xb2 = B
  then
    out(ca, aenc(xnb, xpkb)).

#######################################
#    Description of principal B :     #
#######################################

let processB k_S k_B k_A cb =
  in(cb, x);
  let (xna,xa) = adec(x,k_B) in  
  if xa = A
  then
    new N_b;
    out(cb, (B,A));

    in(cb, y);
    let (xpka, xa2) = sdec(x, k_S) in    
    out(cb, aenc((xna,N_b,B),xpka));

    in(cb,z);
    if adec(z, k_B) = N_b
    then out(cb, senc(ok, N_b))
    else out(cb, bad).

let processB_n k_S k_B k_A cb =
  in(cb, x);
  let (xna,xa) = adec(x,k_B) in  
  if xa = A
  then
    new N_b;
    out(cb, (B,A));

    in(cb, y);
    let (xpka, xa2) = sdec(x, k_S) in    
    out(cb, aenc((xna,N_b,B),xpka));

    in(cb,z);
    if adec(z, k_B) = N_b
    then new n; out(cb, senc(n, N_b))
    else out(cb, bad).


#######################################
# 		Main                  #
#######################################

let Proto k_A k_B k_S c ca cb cs =
  (processA k_S k_A ca |
   processB k_S k_B k_A cb |
   processS k_A k_B k_I k_S cs).

let Proto_n k_A k_B k_S c ca cb cs =
  (processA k_S k_A ca |
   processB_n k_S k_B k_A cb |
   processS k_A k_B k_I k_S cs).

equivalence (in(c,zz);
   new k_A; new k_B; new k_S;
   out(c,pk(k_A)); out(c,pk(k_B)); out(c, pk(k_S));
  ( (Proto k_A k_B k_S c1 ca1 cb1 cs1)
   |
    (Proto k_A k_B k_S c2 ca2 cb2 cs2)
  )
) and (in(c,zz);
  new k_A; new k_B; new k_S;
  out(c,pk(k_A)); out(c,pk(k_B)); out(c, pk(k_S));
  ( (Proto_n k_A k_B k_S c1 ca1 cb1 cs1)
    |
    (Proto_n k_A k_B k_S c2 ca2 cb2 cs2)
  )
).
