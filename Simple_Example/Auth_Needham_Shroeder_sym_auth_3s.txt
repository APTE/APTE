# Needham Schroeder Symmetric Key
#
# Principal A,B,S
#
# Key know by the principal : 
# K_as -> A, S
# K_bs -> B ,S
# K_ab fresh generated by S

free A.
free B.
free I.
free bad.

free c.
free ca.
free cb.
free cs.

free ca2.
free cb2.
free cs2.

free ca3.
free cb3.
free cs3.
free K_is.

#######################################
#    Description of principal S :     #
#######################################

let processS K_ab K_as K_bs c_s =

	in(c_s,w) ; let (a,b,n_a) = w in 
	(
	if a = A && b = B then out(c_s,senc((n_a,b,K_ab,senc((K_ab,a),K_bs)),K_as))
	|
	if a = I && b = A then out(c_s, senc((n_a,b,K_ab,senc((K_ab,a),K_as)),K_is))
	|
	if a = I && b = B then out(c_s, senc((n_a,b,K_ab,senc((K_ab,a),K_bs)),K_is))
	|
	if a = A && b = I then out(c_s, senc((n_a,b,K_ab,senc((K_ab,a),K_bs)),K_is))
	).

#######################################
#    Description of principal A :     #
#######################################

let processA K_as i c_s =
  new N_a;
  out(c_s,(A,i,N_a));
  in(c_s,w);
  let (n_a,b,k_ab,cypher_b) = sdec(w,K_as) in
  if n_a = N_a && b = i
  then
    out(c,cypher_b); 
    in(c,z);
    out(c,senc(sdec(z,k_ab),k_ab)).

#######################################
#    Description of principal B :     #
#######################################

let processB_1 K_bs K_ab c =
  in(c,w);
  let (k_ab,a)= sdec(w,K_bs) in
  if a = A 
  then
    new N_b;
    out(c,senc(N_b,k_ab));
    in(c,t);
    if sdec(t,k_ab) = N_b
    then 
      in(c,z); 
      if z = N_b
      then 
        out(bad,bad).


let processB_2 K_bs K_ab c =
  in(c,w);
  let (k_ab,a)= sdec(w,K_bs) in
  if a = A 
  then
    new N_b;
    out(c,senc(N_b,k_ab));
    in(c,t);
    if sdec(t,k_ab) = N_b
    then 
      in(c,z).

#######################################
#   			Main                  #
#######################################

let P_1 = in(c,zz);
  new K_as; new K_bs ; new K_ab ;
( processS K_ab K_as K_bs cs |
  processA K_as I ca |
  processB_1 K_bs K_ab cb |
  processS K_ab K_as K_bs cs2 |
  processA K_as I ca2 |
  processB_1 K_bs K_ab cb2 |
  processS K_ab K_as K_bs cs3 |
  processA K_as I ca3 |
  processB_1 K_bs K_ab cb3

).

let P_2 = in(c,zz);
  new K_as; new K_bs ; new K_ab ;
( processS K_ab K_as K_bs cs |
  processA K_as I ca |
  processB_2 K_bs K_ab cb |
  processS K_ab K_as K_bs cs2 |
  processA K_as I ca2 |
  processB_2 K_bs K_ab cb2 |
  processS K_ab K_as K_bs cs3 |
  processA K_as I ca3 |
  processB_2 K_bs K_ab cb3
).

equivalence P_1 and P_2.
