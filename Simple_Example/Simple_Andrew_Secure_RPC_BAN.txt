# BAN modified Andrew Secure RPC
# http://www.lsv.ens-cachan.fr/Software/spore/andrewBAN.html

# EQUIVALENCE 1: We check the strong secrecy of the newly generated secret key
# should be equivalent

# EQUIVALENCE 2: We check (strong) authentification of B for A
# should be equivalent

fun succ/1.
free ca1.
free cb1.
free ca2.
free cb2.
free A.
free B.
free ok.
free error.
free errorFresh.

### Description of the role of Alice
let p_Alice kab ca =
  in(ca,z);
  new Na;
  out(ca, (A,senc(Na,kab)));
  in(ca, x);
  let (sNa, nb) = sdec(x,kab) in
  if sNa = succ(Na)
  then out(ca, senc(succ(nb),kab));
       in(ca, y);
       let (kabb, nbb, na) = sdec(y,kab) in
       if na = Na
       then out(ca, ok).   


### Description of the role of Bob
let p_Bob kab cb Kab2 =
  in(cb,x);
  let (a,cipher) = x in
  let na = sdec(cipher,kab) in
  new Nb;
  out(cb, senc((succ(na), Nb),kab));
  in(cb,y);
  let snb = sdec(y,kab) in
  if snb = succ(Nb)
  then new Nbb;
       out(cb,senc((Kab2,Nbb,na),kab)).


let AB kab ca cb kab2 = (p_Alice kab ca | p_Bob kab cb kab2).
let ABAB = new kab; new kab1; new kab2; ((AB kab ca1 cb1 kab1) | (AB kab ca2 cb2 kab1)).
let ABAB2 = new kab;new kab1; new kab2; ((AB kab ca1 cb1 kab1) | (AB kab ca2 cb2 kab2)).

equivalence ABAB and ABAB2.


# CHECKING AUTHENTIFICATION (Second EQU)

let p_Alice_auth kab ca Kab2 =
  in(ca,z);
  new Na;
  out(ca, (A,senc(Na,kab)));
  in(ca, x);
  let (sNa, nb) = sdec(x,kab) in
  if sNa = succ(Na)
  then out(ca, senc(succ(nb),kab));
       in(ca, y);
       let (kabb, nbb, na) = sdec(y,kab) in
       if kabb = Kab2
       then if na = Na
       then out(ca, ok)
       else out(ca,errorFresh)
       else out(ca,error).


let ABa kab ca cb kabNew = (p_Alice_auth kab ca kabNew | p_Bob kab cb kabNew).
let ABABa = new kab; new kab1; new kab2; ((ABa kab ca1 cb1 kab1) | (ABa kab ca2 cb2 kab1)).
let ABABa2 = new kab;new kab1; new kab2; ((ABa kab ca1 cb1 kab1) | (ABa kab ca2 cb2 kab2)).

equivalence ABABa and ABABa2.
