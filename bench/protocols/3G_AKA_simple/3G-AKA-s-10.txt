# G3/UMTS: AKA - Key Agreement protocol between
#          - a mobile station (MS) (i.e. a mobile phone) and
#          - a serving network (SN) (i.e., an antenna)
# We test the strong secrecy of the shared key received by SN

(* public communication channel *)
free c.
free cs1.
free cm1.
free cs2.
free cm2.
free cs3.
free cm3.
free cs4.
free cm4.
free cs5.
free cm5.

(* constant values *)
free authreq.
free authrep.
free errormac.
free errorsynch.
free ok.

(* UMTS AKA protocol specific mac and key generation functions *)
fun f1/2.
fun f2/2.
fun f3/2.
fun f5/2.

###############################################
#   Description of role Mobile Station played:
#  - on channel cm
#  - with a shared knwoledge (with SN) osqn
#  - with mac/enc key k
###############################################

let MS kimsi osqn cm = 
   in(cm, x);
    let (xreq, xrand, xmsg, xmac) = x in
    if xreq = authreq then
    let ak = f5(xrand, kimsi) in
    let xsqn  = sdec(xmsg, ak) in
    if xsqn = osqn then
    let mac = f1((xrand, xsqn), kimsi) in
    if xmac = mac then (
       	  let res = f2(xrand, kimsi) in
	  let ck = f3(xrand, kimsi) in
	  out(cm, res)
)
        else out(cm,errormac)
    else out(cm,errorsynch).

################################################
#   Description of role Serving Netwotk played:
#  - on channel cs
#  - with a shared knwoledge (with MS) osqn
#  - with mac/enc key k
###############################################


let SN kimsi osqn cs =
    new rand;
    let ak = f5(rand, kimsi) in
    let mac = f1((rand, osqn), kimsi) in
    let autn = (senc(osqn, ak), mac) in
    out(cs, (authreq,rand, autn));
    in(cs, xres);
    if xres = f2(rand,kimsi) then  0.


let SN_real kimsi osqn cs =
    new rand;
    let ak = f5(rand, kimsi) in
    let mac = f1((rand, osqn), kimsi) in
    let autn = (senc(osqn, ak), mac) in
    out(cs, (authreq,rand, autn));
    in(cs, xres);
    if xres = f2(rand,kimsi) then    
    out(cs,senc(ok,f3(rand,kimsi))).

let SN_ideal kimsi osqn cs =
 new rand;
    let ak = f5(rand, kimsi) in
    let mac = f1((rand, osqn), kimsi) in
    let autn = (senc(osqn, ak), mac) in
    out(cs, (authreq,rand, autn));
    in(cs, xres);
    if xres = f2(rand,kimsi) then  
    new k;  
    out(cs,senc(ok,k)).

########################################
# Whole systems (idealized and real)
# If we consider multiple sessions, we
# reuse the same key k (we consider same
# phone) but we must choose different
# fresh osqn (modeling an internal sync.
# counter of sessions.
########################################

let AKA_real = in(c,zz);
  new kimsi;
  new osqn1; new osqn2; new osqn3; new osqn4; new osqn5;
 ((MS kimsi osqn1 cm1) | (SN_real kimsi osqn1 cs1) | (MS kimsi osqn2 cm2) | (SN kimsi osqn2 cs2) 
| (MS kimsi osqn3 cm3) | (SN kimsi osqn3 cs3) | (MS kimsi osqn4 cm4) | (SN kimsi osqn4 cs4) |
| (MS kimsi osqn5 cm5 | (SN kimsi osqn5 cs5)).

let AKA_ideal = in(c,zz);
  new kimsi;
  new osqn1; new osqn2; new osqn3; new osqn4; new osqn5;
 ((MS kimsi osqn1 cm1) | (SN_ideal kimsi osqn1 cs1) | (MS kimsi osqn2 cm2) | (SN kimsi osqn2 cs2)
 | (MS kimsi osqn3 cm3) | (SN kimsi osqn3 cs3)  | (MS kimsi osqn4 cm4) | (SN kimsi osqn4 cs4) |
 | (MS kimsi osqn5 cm5 | (SN kimsi osqn5 cs5)).


equivalence AKA_real and AKA_ideal.
