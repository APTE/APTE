# Needham Schroeder Symmetric Key
#
# Principal A,B,S
#
# Key know by the principal : 
# K_as -> A, S
# K_bs -> B ,S
# K_ab fresh generated by S

free A.
free B.
free I.
free c.
free c_1.
free c_2.
free c_3.
free c_4.
free c_s.
free k_I.
free bad.

#######################################
#    Description of principal A :     #
#######################################

let processA k_S k_A =
  new N_a;
  out(c_1,aenc((N_a,A),pk(k_I)));
  in(c_2,y);
  let (n_a,n_I) = adec(y,k_A) in
  if n_a = N_a
  then
    out(c_3,aenc(n_I,pk(k_I))).

#######################################
#    Description of principal B :     #
#######################################

let processB_1 k_S k_B k_A =
  in(c_1,x);
  let (n_a,a) = adec(x,k_B) in
  
  if a = A
  then
    new N_b;
    out(c_2,aenc((n_a,N_b),pk(k_A)));
    in(c_3,y);
    if adec(y,k_B) = N_b
    then
    in(c_4,z);
    if z = N_b
    then out(c_s,bad).


let processB_2 k_S k_B k_A =
  in(c_1,x);
  let (n_a,a) = adec(x,k_B) in
  
  if a = A then
  new N_b;
  out(c_2,aenc((n_a,N_b),pk(k_A)));
  in(c_3,y);
  if adec(y,k_B) = N_b
  then
    in(c_4,z).

#######################################
#   			Main                  #
#######################################

let P_1 =
  new k_A; new k_B; new k_S; out(c,pk(k_A)); out(c,pk(k_B)); (processA k_S k_A | processB_1 k_S k_B k_A).

let P_2 = 
  new k_A; new k_B; new k_S; out(c,pk(k_A)); out(c,pk(k_B)); (processA k_S k_A | processB_2 k_S k_B k_A).

equivalence P_1 and P_2.