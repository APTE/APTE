
module type HType = sig
  type t
  val compare : t -> t -> int
  val equal : t -> t -> bool
  val hash : t -> int
  val to_string : t -> string
end

module type S = sig

  module State : HType
  module Action : HType

  module ActionSet : sig
    include Set.S with type elt = Action.t
    val to_string : t -> string
  end
  module ActionMap : Map.S with type key = Action.t

  (** Set of actions that are enabled/executable in a given state. *)
  val enabled : State.t -> ActionSet.t

  (** Map of a state's transitions. *)
  val successors : State.t -> State.t ActionMap.t

  (** [force_dependent a b] must return true when the actions should be
    * considered as dependent for reasons that are not apparent in the states,
    * typically because of a symbolic abstraction. *)
  val force_dependent : Action.t -> Action.t -> bool

  (** Actions are allowed to contain annotations that are not necessarily
    * preserved by semantics-preserving permutations.[<2;159;34m
    * [translate a b] returns a "residual" action [a'] such that should be
    * seen as the equivalent of [a] when executed after rather than before
    * [b]. *)
  val translate : Action.t -> Action.t -> Action.t

end

module Make (T:S) = struct

  open T

  module SMemo = Memo.Make(State)
  module AMemo = Memo.Make(Action)

  module StateSet = Set.Make(State)

  (** Set of reachable states from a given state. *)
  let reachable_states = SMemo.make_rec (fun reachable_states s ->
    ActionMap.fold
      (fun _ s' res ->
         StateSet.union (StateSet.add s res) (reachable_states s'))
      (successors s)
      StateSet.empty)

  (** Compute the number of maximal traces. *)
  let nb_traces = SMemo.make_rec (fun nb_traces s ->
    let succ = successors s in
      if ActionMap.is_empty succ then 1 else
        ActionMap.fold
          (fun _ s' res ->
             res + nb_traces s')
          succ
          0)

  let rec show_traces acc s =
    let succ = successors s in
      if ActionMap.is_empty succ then
        let rec pp = function
          | [] -> ()
          | a::acc -> pp acc ; Printf.printf "%s." (Action.to_string a)
        in pp acc ; Printf.printf "\n"
      else
        ActionMap.iter
          (fun a s' -> show_traces (a::acc) s')
          succ

  (** Type of traces, represented in reverse order. *)
  type trace = {
    dest : State.t ;
    prev : (Action.t*trace) option
  }

  let (@) t (a,s) = { dest = s ; prev = Some (a,t) }

  let rec iter_traces f s =
    let rec aux prefix =
      let succ = successors prefix.dest in
        if ActionMap.is_empty succ then
          f prefix
        else
          ActionMap.iter
            (fun a s' -> aux (prefix @ (a,s')))
            succ
    in aux { dest = s ; prev = None }

  let rec show_trace t =
    match t.prev with
      | None ->
          Printf.printf "%s" (State.to_string t.dest)
      | Some (a,t') ->
          show_trace t' ;
          Printf.printf
            " -[%s]-> %s"
            (Action.to_string a)
            (State.to_string t.dest)

  let rec show_traces s =
    iter_traces
      (fun t ->
         Printf.printf " * " ; show_trace t ; Printf.printf "\n")
      s

end
